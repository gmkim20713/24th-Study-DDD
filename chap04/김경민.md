# 리포지터리와 모델 구현


## 4.1 JPA를 이용한 리포지터리 구현

### 모듈 위치
- 리포지터리 인터페이스는 도메인 영역에 속하고, 리포지터리를 구현한 클래스는 인프라스트럭처 영역에 속한다. (DIP를 따른 것)
  - 팀 표준에 따라 구현 클래스를 domain.impl과 같은 패키지에 위치시킬 수도 있지만, 인프라스트럭처에 대한 의존을 낮추는 좋은 설계 원칙을 따르는 것은 아니다.

<img width="269" alt="image" src="https://github.com/gmkim20713/24th-Study-DDD/assets/68195241/2c477f9f-7a91-4b0b-9388-c0ebdc642d0b">

### 리포지터리 기본 기능 구현
- 리포지터리 제공 기본 기능
  1. ID로 애그리거트 조회하기
  2. 애그리거트 저장하기
    ```java
    public interface OrderRepository {
      Order findById(OrderNo no);
      void save(Order order);
    }
    ```
- 인터페이스는 애그리거트 루트를 기준으로 작성한다.

#### 조회 기능
- 애그리거트를 조회하는 기능의 이름을 지을 때, 널리 사용되는 규칙은 ```'findBy프로퍼티이름(프로퍼티 값)'``` 형식을 사용하는 것이다.
  - ID 외에 다른 조건으로 애그리거트를 조회할 때에는 JPA의 Criteria나 JPQL을 사용할 수 있다.
- 한 개의 객체를 리턴하는 경우는...
  - 해당하는 애그리거트가 존재하면 : 애그리거트 리턴
  - 해당하는 애그리거트가 존재하지 않으면 : null 리턴
    - null을 사용하고 싶지 않다면 Optional 사용 가능

- 한 개 이상의 객체를 리턴하는 경우는 컬랙션 타입 중 List를 사용할 수 있다.

#### 저장 기능
- save() 메서드는 전달받은 애그리거트를 저장한다.

#### 수정 기능
- JPA를 사용하면 트랜잭션 번위에서 변경한 데이터를 자동으로 DB에 반영하기 때문에, 애그리거트를 수정한 결과를 저장소에 반영하는 메서드를 추가할 필요는 없다.

#### 삭제 기능
- 삭제 기능을 위한 메서드는 삭제할 애그리거트를 파라미터로 전달받는다.
- 삭제 요구사항이 있더라도 데이터를 실제로 삭제하는 것이 아닌, 삭제 플래그를 사용해서 데이터를 화명에 보여줄지 여부를 결정하는 방식으로 구현하기도 한다.


## 4.2 스프링 데이터 JPA를 이용한 리포지터리 구현
> ```스프링 데이터 JPA``` 지정한 규칙에 맞게 리포지터리 인터페이스를 정의하면 리포지터리를 구현한 객체를 알아서 만들어 스프링 빈으로 등록해 준다.

### 규칙
- org.springframework.data.repository.Repository<T, ID> 인터페이스 상속
- T는 엔티티 타입을 지정하고 ID는 식별자 타입을 지정

### 엔티티 저장 기능
- ```Order save(Order entity)```
- ```void save(Order entity)```

### 식별자를 이용한 엔티티 조회 기능
- ```Order findById(OrderNo id)```
- ```Optional<Order> findById(OrderNo id)```

### 특정 프로퍼티를 이용한 엔티티 조회 기능
- ```List<Order> findByOrderer(Orderer orderer)```

### 중첩 프로퍼티를 이용한 엔티티 조회 기능
- ```List<Order> findByOrderMemberId(MemberId memberId)```

### 엔티티 삭제 기능
- ```void delete(Order order)```
- ```void deleteById(OrderNo id)```


## 4.3 매핑 구현

### 엔티티와 밸류 기본 매핑 구현
#### 기본 규칙
- 애그리거트 루트는 엔티티이므로 ```@Entity```로 매핑 설정한다.

#### 한 테이블에 엔티티와 밸류 데이터가 같이 있다면?
- 밸류는 ```@Embeddable```로 매핑 설정한다.
- 밸류 타입 프로퍼티는 ```@Embedded```로 매핑 설정한다.

### 기본 생성자
- 엔티티와 밸류의 생성자는 객체를 생성할 때 필요한 것을 전달받는다.
  - 불변 타입이면 생성 시전에 필요한 값을 모두 전달받으므로 값을 변경하는 set 메서드를 제공하지 않는다.
  - 이는 기본 생성자(파라피터가 없는)를 추가할 필요가 없다는 것을 의미한다.
- JPA에서 ```@Entity```와 ```@Embeddable```로 클래스를 매핑하려면 기본 생성자를 제공해야한다.
  - DB에서 데이터를 읽어와 매핑된 객체를 생성할 떄 기본 생성자를 사용해서 객체를 생성하기 때문이다.
- 기본 생성자는 JPA 프로바이더가 객체를 생성할 때만 사용한다.
  - 기본 생성자를 다른 코드에서 사용하면 값이 없는 온전하지 못한 객체를 만들게 된다.
  - 다른 코드에서 기본 생성자를 사용하지 못하도록 protected로 선언한다.

### 필드 접근 방식 사용
- (작성 중!)


## 4.4 애그리거트 로딩 전략
> "애그리거트 루트를 로딩하면 루트에 속한 모든 객체가 완전한 상태여야 한다."
> 
> ```이유```
> 1. 상태를 변경하는 기능을 실행할 때 애그리거트 상태가 완전해야 한다.
> 2. 표현 영역에서 애그리거트의 상태 정보를 보여줄 때 필요하다.

### 즉시 로딩
- 즉시 로딩은 조회 시점에서 애그리거트를 완전한 상태가 되도록 한다. (애그리거트 루트를 로딩하는 시점에 애그리거트에 속한 모든 객체를 함꼐 로딩할 수 있다.)
- 즉시 로딩 설정은 ```@Entity```나 ```@Embeddable```에 대해 다르게 동작한다.

### 지연 로딩
- 지연 로딩은 동작 방식이 항상 동일하기 때문에 즉시 로딩처럼 경우의 수를 따질 필요가 없는 장점이 있다.
- 지연 로딩을 즉시 로딩보다 쿼리 실행 횟수가 많아질 가능성이 더 높다.

### 즉시 로딩 vs. 지연 로딩
- 보통 조회 성능 문제로 즉시 로딩 방식을 사용하지만, 조회되는 데이터 개수가 많아지면 즉시 로딩 방식을 사용할 때 성능(실행 빈도, 트래핑, 지연 로딩 시 실행 속도 등)을 검토해 봐야 한다.
- 상태 변경 기능을 실행하기 위해 조회 시점에 즉시 로딩을 이용해서 애그리거트를 완전한 상태로 로딩할 필요는 없다.
  - JPA는 트랜잭션 범위 내에서 지연 로딩을 허용하기 때문에 실제로 상태를 변경하는 시점에서 필요한 구성 요소만 로딩해도 문제가 되지 않는다.
- 일반적인 애플리케이션은 상태 변경을 실행하는 빈도보다 조회 기능을 실행하는 빈도가 훨씬 높다.
  - 상태 변경을 위한 지연 로딩을 사용할 때 발생하는 추가 쿼리로 인한 실행 속도 저하는 보통 문제가 되지 않는다.


## 4.5 애그리거트의 영속성 전파
> "애그리거트가 완전한 상태여야 한다는 것은 애그리거트 루트를 조회할 때뿐만 아니라 저장하고 삭제할 때도 하나로 처리해야 함을 의미한다."

- ```@Embeddable``` 매핑 타입은 함께 저장되고 삭제되므로 cascade 속성을 추가로 설정하지 않아도 된다.
- 애그리거트에 속한 ```@Entity``` 타입에 대한 매핑은 cascade 속성을 사용해서 저장과 삭제 시에 함께 처리되로록 설정해야 한다.
  - ```@OneToOne```, ```@OneToMany```는 cascade 속성의 기본값이 없다. (```CascadeType.PERSIST```, ```CascadeType.REMOVE```을 설정 가능하다)

## 4.6 식별자 생성 기능


## 4.7 도메인 구현과 DIP